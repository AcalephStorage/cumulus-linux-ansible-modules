#!/usr/bin/env python
#
# Copyright (C) 2015, Cumulus Networks www.cumulusnetworks.com
#
#
DOCUMENTATION = '''
---
module: cl_interface
author: Stanley Karunditu
short_description: Configures a front panel port, loopback or \
management port on Cumulus Linux.
description:
    - Configures a front panel, sub-interface, SVI, management \
or loopback port on a Cumulus Linux switch. For bridge ports \
use the cl_bridge module. For bond ports use the \
cl_bond module. When configuring bridge related features like \
the "vid" option, please follow the guidelines for configuring \
"vlan aware" bridging. For more details \
review the Layer2 Interface Guide @ \
http://docs.cumulusnetworks.com
options:
    name:
        description:
            - name of the interface
        required: true
    alias_name:
        description:
            - add a port description
    ipv4:
        description:
            - list of IPv4 addresses to configure on the interface. \
use X.X.X.X/YY syntax.
    ipv6:
        description:
            - list of IPv6 addresses  to configure on the interface. \
use X:X:X::X/YYY syntax
    addr_method:
        description:
            - can be loopback for loopback interfaces or dhcp for dhcp \
interfaces.
    link_speed:
        description:
            - set speed of the swp(front panel) or \
management(eth0) interface. speed is in MB
    mtu:
        description:
            - set MTU. Configure Jumbo Frame by setting MTU to 9000.

    virtual_ip:
        description:
            - define IPv4 virtual IP used by the Cumulus VRR feature
    virtual_mac:
        description:
            - define Ethernet mac associated with Cumulus VRR feature
    vids:
        description:
            - in vlan aware mode, lists vlans defined under the interface
    pvid:
        description:
            - in vlan aware mode, defines vlan that is the untagged vlan
requirements: [ Alternate Debian network interface manager - \
ifupdown2 @ github.com/CumulusNetworks/ifupdown2 ]
notes:
    - For the config to be activated, i.e installed in the kernel, \
"service networking reloaded" needs be be executed. See EXAMPLES section.
'''

EXAMPLES = '''
# Options ['virtual_mac', 'virtual_ip'] are required together
# configure a front panel port with an IP
cl_interface: name=swp1  ipv4=10.1.1.1/24

# configure front panel to use DHCP
cl_interface: name=swp2 addr_family=dhcp

# configure a SVI for vlan 100 interface with an IP
cl_interface: name=bridge.100 ipv4=10.1.1.1/24

# configure subinterface with an IP
cl_interface: name=bond0.100  alias_name='clag peer link' ipv4=10.1.1.1/24

# configure ports using variable data structure
cl_interface:
    name: {{ item.key }}
    ipv4:  {{ item.value.ipv4|default(none) }}
    ipv6: {{ item.value.ipv6|default(none) }}
    alias_name: {{ item.value.alias|default(none) }}
    addr_method: {{ item.value.addr_method|default(none) }}
    link_speed: {{ item.value.link_speed|default(none) }}
    mtu: {{ item.value.mtu|default(none) }}
    vids: {{ item.value.vids|default(none) }}
    virtual_ip: {{ item.value.virtual_ip|default(none) }}
    virtual_mac: {{ item.value.virtual_mac|default(none) }}
with_dict=cl_interfaces

# In vars file
# ============
cl_interfaces:
    swp1:
        alias_name: 'uplink to isp'
        ipv4: '10.1.1.1/24'
    swp2:
        alias_name: 'l2 trunk connection'
        vids: [1, 50]
    swp3:
        link_speed: 1000
        alias_name: 'connects to 1G link'
##########
#   br0 interface is configured by cl_bridge
##########
    br0.100:
        alias_name: 'SVI for vlan 100'
        ipv4: '10.2.2.2/24'
        ipv6: '10:2:2::2/127'
        virtual_ip: '10.2.2.254'
        virtual_mac: '00:00:5E:00:10:10'


'''

# handy helper for calling system calls.
# calls AnsibleModule.run_command and prints a more appropriate message
# exec_path - path to file to execute, with all its arguments.
# E.g "/sbin/ip -o link show"
# failure_msg - what message to print on failure
def run_cmd(module, exec_path):
    (_rc, out, _err) = module.run_command(exec_path)
    if _rc == 1:
        failure_msg = "Failed; %s Error: %s" % (exec_path, _err)
        module.fail_json(msg=failure_msg)
    else:
        return out

def current_iface_config(module):
    # due to a bug in ifquery, have to check for presence of interface file
    # and not rely solely on ifquery. when bug is fixed, this check can be
    # removed
    _ifacename = module.params.get('name')
    _int_dir = module.params.get('location')
    module.custom_current_config = {}
    if os.path.exists(_int_dir + '/' + _ifacename):
        _cmd = "/sbin/ifquery -o json %s" % (module.params.get('name'))
        module.custom_current_config = json.loads(
            run_cmd(module, _cmd))[0]

def build_address(module):
    # if addr_method == 'dhcp', dont add IP address
    if module.params.get('addr_method') == 'dhcp':
        return
    _ipv4 = module.params.get('ipv4')
    _ipv6 = module.params.get('ipv6')
    _addresslist = []
    if _ipv4 is not None and len(_ipv4) > 0:
        _addresslist += _ipv4

    if _ipv6 is not None and len(_ipv6) > 0:
        _addresslist += _ipv6
    module.custom_desired_config['config']['address'] = ' '.join(_addresslist)

def build_vids(module):
    _vids = module.params.get('vids')
    if _vids is not None and len(_vids) > 0:
        module.custom_desired_config['config']['bridge-vids'] = ' '.join(_vids)

def build_pvid(module):
    _pvid = module.params.get('pvid')
    if _pvid is not None:
        module.custom_desired_config['config']['bridge-pvid'] = str(_pvid)

def build_speed(module):
    _speed = module.params.get('link_speed')
    if _speed is not None:
        module.custom_desired_config['config']['link-speed'] = str(_speed)
        module.custom_desired_config['config']['link-duplex'] = 'full'

def build_generic_attr(module, _attr):
    _value = module.params.get(_attr)
    if _value is not None:
        module.custom_desired_config['config'][_attr] = str(_value)

def build_alias_name(module):
    alias_name = module.params.get('alias_name')
    if alias_name is not None:
        module.custom_desired_config['config']['alias'] = alias_name

def build_desired_iface_config(module):
    """
    take parameters defined and build ifupdown2 compatible hash
    """
    module.custom_desired_config = {
        'addr_family': None,
        'auto': True,
        'config': {},
        'name': module.params.get('name')
    }

    if module.params.get('addr_method'):
        module.custom_desired_config['addr_family'] = 'inet'
    build_address(module)
    build_vids(module)
    build_pvid(module)
    build_speed(module)
    build_alias_name(module)
    for _attr in ['mtu']:
        build_generic_attr(module, _attr)

def config_dict_changed(module):
    """
    return true if 'config' dict in hash is different
    between desired and current config
    """
    current_config = module.custom_current_config.get('config')
    desired_config = module.custom_desired_config.get('config')
    return current_config != desired_config

def config_changed(module):
    """
    returns true if config has changed
    """
    if config_dict_changed(module):
        return True
    # check if addr_method is changed
    return module.custom_desired_config.get('addr_method') != \
        module.custom_current_config.get('addr_method')

def replace_config(module):
    temp = tempfile.NamedTemporaryFile()
    desired_config = module.custom_desired_config
    # by default it will be something like /etc/network/interfaces.d/swp1
    final_location = module.params.get('location') + '/' + \
        module.params.get('name')
    # make sure to put hash in array or else ifquery will fail
    # write to temp file
    try:
        temp.write(json.dumps([desired_config]))
        _cmd = "/sbin/ifquery -a -i %s -t json > %s " % \
            (temp.name, final_location)
        run_cmd(module, _cmd)
    finally:
        temp.close()


def main():
    module = AnsibleModule(
        argument_spec=dict(
            name=dict(required=True, type='str'),
            ipv4=dict(type='list'),
            ipv6=dict(type='list'),
            alias_name=dict(type='str'),
            addr_method=dict(type='str',
                             choices=['loopback', 'dhcp']),
            link_speed=dict(type='int'),
            mtu=dict(type='int'),
            virtual_ip=dict(type='str'),
            virtual_mac=dict(type='str'),
            vids=dict(type='list'),
            pvid=dict(type='int'),
            location=dict(type='str',
                                default='/etc/network/interfaces.d')
        ),
        required_together=[
            ['virtual_ip', 'virtual_mac']
        ]
    )

    if not os.path.exists(module.params.get('location')):
        module.fail_json(msg="%s does not exist. Please create it")

    ifacename = module.params.get('name')
    _changed = False
    _msg = "interface %s config not changed" % (ifacename)
    current_iface_config(module)
    build_desired_iface_config(module)
    if config_changed(module):
        replace_config(module)
        _msg = "interface %s config updated" % (ifacename)
        _changed = True

    module.exit_json(changed=_changed, msg=_msg)

# import module snippets
from ansible.module_utils.basic import *
import json
import tempfile
import os

if __name__ == '__main__':
    main()
